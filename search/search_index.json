{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Stat 614.01 - Data Analysis Using Statistical Software Course Information Class time: MoTuWeTh 5:45 - 7:20pm Classroom: Hunter North 305 Instructor: Bora Ferlengez Best way to reach to me is shooting a message in our Telegram chat (stats/software related comments/questions) or send a private message (personal issues) on Telegram. But if you want to send an email: bora.ferlengez@gmail.com Office hours : MoTuWeTh 5:00 - 5:30pm (HE924), or after class, or by appointment. Textbook: R by Example, by Jim Albert and Maria Rizzo. 2012. Free download from the Hunter College library website. ISBN: 978-1-4614-1364-6. Reference Textbook: Introduction to Statistics and Data Analysis, Peck, Olsen and Devore, 5th edition. ISBN:978-1-305-11534-7.","title":"Syllabus"},{"location":"#welcome-to-stat-61401-data-analysis-using-statistical-software","text":"","title":"Welcome to Stat 614.01 - Data Analysis Using Statistical Software"},{"location":"#course-information","text":"Class time: MoTuWeTh 5:45 - 7:20pm Classroom: Hunter North 305 Instructor: Bora Ferlengez Best way to reach to me is shooting a message in our Telegram chat (stats/software related comments/questions) or send a private message (personal issues) on Telegram. But if you want to send an email: bora.ferlengez@gmail.com Office hours : MoTuWeTh 5:00 - 5:30pm (HE924), or after class, or by appointment. Textbook: R by Example, by Jim Albert and Maria Rizzo. 2012. Free download from the Hunter College library website. ISBN: 978-1-4614-1364-6. Reference Textbook: Introduction to Statistics and Data Analysis, Peck, Olsen and Devore, 5th edition. ISBN:978-1-305-11534-7.","title":"Course Information"},{"location":"chapter_1_code_snippets/","text":"Getting Started We have seen most of the material below before. The examples below will provide good practice. Having written that, there are quite a number of new commands/ideas, as well. Example 1 The purpose of this example is to get familiar how to create a vector using the combine c() function. Once you have a vector, arithmetic operations can be run using very simple syntax. You can make vectors algebraically interact with scalars (i.e. numbers) or with other vectors of same length (termwise). # create a vector and assign a variable. temps = c(51.9, 51.8, 51.9, 53) # subtract 32 from every item in the vector temps, and multiply the differences by 5/9, # that's the conversion formula from fahrenheit to celcius. (5/9) * (temps - 32) # create another vector. CT = c(48, 48.2, 48, 48.7) # when you subtract a vector from another, R runs the subtraction termwise. temps - CT .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 11.0555555555556 11 11.0555555555556 11.6666666666667 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 3.9 3.59999999999999 3.9 4.3 Example 2 In this example, we practice indexing and slicing. By provoding the desired indices, we can grab the items at those indices of a vector. If we want to grab several items at once, the : operator comes very handy to generate a sequence of indices. The two new functions you may want to learn about would be the table() and barplot() functions. table() is used to create a frequency table. more on table() : https://www.statology.org/table-function-in-r/ more on barplot() : https://statisticsglobe.com/barplot-in-r # create two vectors from given data. winner = c(185, 182, 182, 188, 188, 188, 185, 185, 177, 182, 182, 193, 183, 179, 179, 175) opponent = c(175, 193, 185, 187, 188, 173, 180, 177, 183, 185, 180, 180, 182, 178, 178, 173) # you can see the lengths of the vectors in the environment pane of RStudio, # but you may want to compute with that length. # the `length()` function can be used to in those cases. length(winner) # `seq()` function is used to created a vector whose first item is 2008, last item 1948, # and the each item is 4 less than the previous item (i.e. the stepsize of the arithmetic sequence is -4) year = seq(from=2008, to=1948, by=-4) # grabbing the 4th item in the vector `winner`, # and updating that item with the value 189. winner[4] = 189 # grabbing the 5th item in the vector in `winner`, # and updating that item as 189. winner[5] = 189 # instead of the previous two commands, # we can grab the 4th and 5th items and update them with 189. winner[4:5] = 189 # the function `mean()` computes the mean (i.e. average) of a numerical vector. mean(winner) # the average of the `opponent` vector is computed. mean(opponent) # like in example 1, we can compute the difference of vectors (of same length), # that produces of a new vector whose items are the differences of the corresponding values in the given vectors. difference = winner - opponent # we create a data frame from the vectors `year`, `winner`, `opponent` and `difference` # those vectors will be columns of the data frame in the same order of the arguments of the function `data.frame()` data.frame(year, winner, opponent, difference) # the one below is a tricky line: # `winner > opponent` asks for every index of the vectors, if the item of `winner` vector is greater than # the correspondent item in the `opponent` vector. # the result of each of those comparisons is `TRUE` or `FALSE`. # hence `winner > opponent` creates a logical vector. # then that logical vector is assigned the variable name `taller.won` taller.won = winner > opponent # the `TRUE` and `FALSE`s are counted in the `taller.won` vector # the number of `TRUE`s is the the number of the elected president being taller than the other candidate. table(taller.won) # you can create the relative frequency (in percent) table by dividing each frequency by the total frequency # and multiplying by 100. table(taller.won) / 16 * 100 # finally a barplot is constructed. # one minor thing below: we want the values in the horizontal axis to increase as we move to right, # whereas our vectors constructed with election years in decreasing order. # 'rev(difference)' reverses the `difference` vector. # `barplot(rev(difference))` puts a bar at every index of the `rev(difference)` vector as tall as the value at that index. # `xlab` and `ylab` arguments of the `barplot()` function allow us name the x (horizontal) and y (vertical) axes. barplot(rev(difference), xlab=\"Election years 1948 to 2008\", ylab=\"Height difference in cm\") # note that the bars are not labed horizontally, # if you want horizontal labels, you can do the following: barplot(rev(difference), names.arg = rev(year), xlab=\"Election years 1948 to 2008\", ylab=\"Height difference in cm\") # depending on the size of the barplot, some horizontal labels can be skipped as R doesn't want the labels to overlap. # you can also easily draw a scatterplot for the pair of variables: `winner` and `opponent` # for every election, a point is generated whose x coordinate is the winner and y coordinate is the opponent. plot(winner,opponent) 16 183.4375 181.0625 A data.frame: 16 \u00d7 4 year winner opponent difference <dbl> <dbl> <dbl> <dbl> 2008 185 175 10 2004 182 193 -11 2000 182 185 -3 1996 189 187 2 1992 189 188 1 1988 188 173 15 1984 185 180 5 1980 185 177 8 1976 177 183 -6 1972 182 185 -3 1968 182 180 2 1964 193 180 13 1960 183 182 1 1956 179 178 1 1952 179 178 1 1948 175 173 2 taller.won FALSE TRUE 4 12 taller.won FALSE TRUE 25 75 Example 3 In this example, deaths of Prussian soldiers due to horsekicks are studied (I know, we may not be the target audience.) Towards the end of the example, our data is compared to Poisson distribution, which models the probability of a given number of events occurring in a fixed interval of time, like what's the probability that your name is called a fixed number of times during a lecture. To learn more about Poisson distributions, you can take a look at the wikipedia page https://en.wikipedia.org/wiki/Poisson_distribution or these notes for a somewhat intuitive description. # first, the data is stored. # `k` stores the number of deaths # `x` stores the frequencies of the values in `k`. k = c(0, 1, 2, 3, 4) x = c(109, 65, 22, 3, 1) # first, we draw a barplot # remember that the first argument denotes the heights of the bars. # and that the `names.arg` argument in the `barplot` function allows us to specify our horizontal labels. # barplot(x, names.arg = k, ylab=\"Frequencies\", xlab = 'Number of deaths', main = 'Frequency distribution') # to get the relative frequency barplot, we simply divide the frequencies by the total frequency. # and produce a new bar plot using those heights (the name `p` stands for percentage, i suppose.) p = x / sum(x) barplot(p, names.arg=k, ylab='Relative Frequencies', xlab = 'Number of deaths', main = 'Relative Freq Distr') # remember that the mean is a weighted sum of relative frequencies, as we discussed in class # the way the sample mean `r` is computed below is as follows: # `p * k` computes the product of each horizontal value with the height of the corresponding bar. # then those little products are added. that way the sample mean is calculated. r = sum(p * k) # you can think of the variance as the square of the average error of a horizontal value from the mean. # i'll talk more about the variance and standard deviation in the class. v = sum(x * (k - r)^2) / 199 You may find the rest of the example a bit confusing. What's done below is: - First, using our sample mean, the probabilities are modeled using a Poisson distribution. Why Poisson? \"How many deaths per year\" is the kind of thing Poisson distributions model well. Also, Poisson distributions' mean equals their variance, and our sample mean and sample variance are pretty close, which can be taken as further evidence for using Poisson distributions to model our data. # model the theoretical probabilities using a Poisson distribution whose mean equals to our sample mean. # f denotes the relative frequencies (i.e. probabilities). f = r^k * exp(- r) / factorial(k) f .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 0.5433508690745 0.331444030135445 0.101090429191311 0.0205550539355665 0.00313464572517389 We can generate the Poisson distribution above using a built-in function of R . f = dpois(k, r) f .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 0.5433508690745 0.331444030135445 0.101090429191311 0.0205550539355665 0.00313464572517389 Then we multiply those theoretical relative frequencies generated by the Poisson distribution by 200 (our total frequency) and round the results down to get integer (theoretical) frequencies. floor(200*f) .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 108 66 20 4 0 Remember our actual frequencies: x .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 109 65 22 3 1 Note that our frequencies are pretty close to the theoretical frequencies of Poisson distribution with a mean that equals our sample mean, and when the sample size is 200 like ours. Lastly, we combine the vectors k (labels), p (our actual relative frequencies) and f (the theoretical relative frequencies) to see how good our sample data can be modeled by a Poission distribution. This is similar to the comparison of theoretical and our frequencies we did above, except at the relative frequency level. cbind(k, p, f) A matrix: 5 \u00d7 3 of type dbl k p f 0 0.545 0.543350869 1 0.325 0.331444030 2 0.110 0.101090429 3 0.015 0.020555054 4 0.005 0.003134646 Example 4 The purpose of this example is to get familiar with using code snippets in R . One important takeaway from this example is to learn how to use R scripts in RStudio . If you choose File > New File > R Script in RStudio 's top menu and paste the following code snippet (a code snippet is a programming term that refers to a small portion of re-usable source code) into the pane on upper left corner and click the Source key, RStudio will run all the lines you pasted. You can save those code snippets in your hard-drive for future use. A good practice is to have a particular directory on your hard drive for those scripts, you name those files in a descriptive way when saving, you use the extension .R . Example: horsekicks.r One remark: When you want a variable to be displayed on console, you'll need to specify that you want it to be printed by using the print() function in your script. If you want to read more about the print() function: https://riptutorial.com/r/example/1221/printing-and-displaying-strings # Prussian horsekick data # rpois() generates random values according to the Poisson distribution and creates an artificially simulated sample. # we take the mean = .61 like in example 3, and sample size = 200. y = rpois(200, lambda=.61) # create a table of sample frequencies. kicks = table(y) # create a table of sample relative frequencies. sample = kicks / 200 # display the table of sample relative frequencies. print(sample) # create a theoretical relative distribution according to Poisson distribution with mean = 0.61 theoretical = dpois(0:3, lambda=.61) # display the theoretical relative frequencies. print(theoretical) # combine the theoretical and sample relative frequencies in a table: cbind(theoretical, Sample) # print the table print(cbind(theoretical, Sample)) y 0 1 2 3 4 0.525 0.320 0.130 0.020 0.005 [1] 0.54335087 0.33144403 0.10109043 0.02055505 A matrix: 4 \u00d7 2 of type dbl theoretical Sample 0 0.54335087 0.515 1 0.33144403 0.330 2 0.10109043 0.135 3 0.02055505 0.020 theoretical Sample 0 0.54335087 0.515 1 0.33144403 0.330 2 0.10109043 0.135 3 0.02055505 0.020 One interesting remark is that the actual data in example 3 fits the theoretical Poisson distribution better than the simulated data in example 4. The R Help System # to ask about a function/keyword. ?barplot # alternative way to ask about a function/keyword. help(barplot) # searches through the help documentation for the keyword and finds all the documentations that contain the keyword. ??dpois # searches through the help documentation for the keyword and finds all the documentations that contain the keyword. help.search(\"dpois\") # to get an example of how to use a function. example(mean) mean> x <- c(0:10, 50) mean> xm <- mean(x) mean> c(xm, mean(x, trim = 0.10)) [1] 8.75 5.50 # usually, there is an example at the end of the help file, as well. ?mean Functions Example 5 In this example, defining and using a function are illustrated. We have discussed what functions are and how to define a function (the syntax of defining functions) last week. # defining the function whose name will be var.n # and which computes the sample variance of a vector of numbers. var.n = function(x){ v = var(x) n = NROW(x) v * (n - 1) / n } # using the function. temps = c(51.9, 51.8, 51.9, 53) var(temps) var.n(temps) 0.323333333333334 0.242500000000001 Example 6 Omitted, because we don't need to discuss integration (a calculus operation) at this point. Example 7 The ( R ) function curve() which draws the graph of the (mathematical & R ) function in its argument. # remark: if the definition is one line { } are not needed. f = function(x, a=1, b=1) x^(a-1) * (1-x)^(b-1) # graphing a function from real numbers to real numbers. # remark: the function to be graphed should always be defined in terms of x. curve(f(x,2,5), from=0, to=1) # if you like, you can label the x and y axes. curve(f(x,2,5), from=0, to=1, xlab=\"inputs\", ylab='outputs') Vectors and Matrices Example 8 Below, we create a matrix that represents the class mobility of generations. The entry $P_{ij}$ (namely, the entry in row $i$, column $j$) represents the probability the child being in the class represented by column $j$, if the parents are in row $i$. # creating a matrix from given data. probs = c(.45, .05, .01, .48, .70, .50, .07, .25, .49) P = matrix(probs, nrow=3, ncol=3) P # naming rows and columns. rownames(P) <- c(\"lower_old\", \"middle_old\", \"upper_old\") colnames(P) <- c(\"lower_new\", \"middle_new\", \"upper_new\") P # how to obtain row sums. rowSums(P) # how to obtain column sums. colSums(P) # grabbing the entry in row 1, column 3 P[1, 3] # grabbing the whole row 1 P[1, ] # grabbing the whole column 2 P[ ,2] A matrix: 3 \u00d7 3 of type dbl 0.45 0.48 0.07 0.05 0.70 0.25 0.01 0.50 0.49 A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.45 0.48 0.07 middle_old 0.05 0.70 0.25 upper_old 0.01 0.50 0.49 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_old 1 middle_old 1 upper_old 1 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_new 0.51 middle_new 1.68 upper_new 0.81 0.07 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_new 0.45 middle_new 0.48 upper_new 0.07 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_old 0.48 middle_old 0.7 upper_old 0.5 # it's probably easier to define a matrix using the following command, # instead of typing two lines as above example. # `byrow=TRUE` argument guarantees that the numbers are placed in rows # and once sufficiently many numbers are placed, # the next number is placed as the first entry in the row below. Q = matrix(c( 0.45, 0.48, 0.07, 0.05, 0.70, 0.25, 0.01, 0.50, 0.49), nrow=3, ncol=3, byrow=TRUE) Q A matrix: 3 \u00d7 3 of type dbl 0.45 0.48 0.07 0.05 0.70 0.25 0.01 0.50 0.49 It's easy to do matrix operations in R . We probably won't need those operations, in case we do, I can go over basic matrix operations. But, here's the list anyways: (Ignore the operations that doesn't make sense to you.) # elementwise multiplication P * Q # exponentiating elementwise P^2 # matrix multiplication P %*% Q # inverse matrix solve(P) A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.2025 0.2304 0.0049 middle_old 0.0025 0.4900 0.0625 upper_old 0.0001 0.2500 0.2401 A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.2025 0.2304 0.0049 middle_old 0.0025 0.4900 0.0625 upper_old 0.0001 0.2500 0.2401 A matrix: 3 \u00d7 3 of type dbl lower_old 0.2272 0.5870 0.1858 middle_old 0.0600 0.6390 0.3010 upper_old 0.0344 0.5998 0.3658 A matrix: 3 \u00d7 3 of type dbl lower_old middle_old upper_old lower_new 2.4549550 -2.254505 0.7995495 middle_new -0.2477477 2.475225 -1.2274775 upper_new 0.2027027 -2.479730 3.2770270 Data Frames Data frames are different from the matrices. The data type of entries of a matrix are all the same. You can think of a matrix as a 2D vector. On the other hand, a data frame consists of vertical vectors. Namely, each item in the same column has the same data type, but items in different columns don't have to have the same data type. It's like stacking vertical vectors horizontally. Example 9 In this example, the purpose is to learn different ways of displaying a data frame and getting summary information of a data frame. # displaying all data USArrests A data.frame: 50 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 Connecticut 3.3 110 77 11.1 Delaware 5.9 238 72 15.8 Florida 15.4 335 80 31.9 Georgia 17.4 211 60 25.8 Hawaii 5.3 46 83 20.2 Idaho 2.6 120 54 14.2 Illinois 10.4 249 83 24.0 Indiana 7.2 113 65 21.0 Iowa 2.2 56 57 11.3 Kansas 6.0 115 66 18.0 Kentucky 9.7 109 52 16.3 Louisiana 15.4 249 66 22.2 Maine 2.1 83 51 7.8 Maryland 11.3 300 67 27.8 Massachusetts 4.4 149 85 16.3 Michigan 12.1 255 74 35.1 Minnesota 2.7 72 66 14.9 Mississippi 16.1 259 44 17.1 Missouri 9.0 178 70 28.2 Montana 6.0 109 53 16.4 Nebraska 4.3 102 62 16.5 Nevada 12.2 252 81 46.0 New Hampshire 2.1 57 56 9.5 New Jersey 7.4 159 89 18.8 New Mexico 11.4 285 70 32.1 New York 11.1 254 86 26.1 North Carolina 13.0 337 45 16.1 North Dakota 0.8 45 44 7.3 Ohio 7.3 120 75 21.4 Oklahoma 6.6 151 68 20.0 Oregon 4.9 159 67 29.3 Pennsylvania 6.3 106 72 14.9 Rhode Island 3.4 174 87 8.3 South Carolina 14.4 279 48 22.5 South Dakota 3.8 86 45 12.8 Tennessee 13.2 188 59 26.9 Texas 12.7 201 80 25.5 Utah 3.2 120 80 22.9 Vermont 2.2 48 32 11.2 Virginia 8.5 156 63 20.7 Washington 4.0 145 73 26.2 West Virginia 5.7 81 39 9.3 Wisconsin 2.6 53 66 10.8 Wyoming 6.8 161 60 15.6 # sometimes (and by sometimes i mean almost always) # there is too much data to display, # in those cases, displaying few top or bottom rows # is a good idea to see what kind of data we have. head(USArrests) # if you want to see more rows from top, you can specify that. head(USArrests, 14) # similarly, you can display few bottom rows, as well, # using the `tail()` function. tail(USArrests) A data.frame: 6 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 A data.frame: 14 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 Connecticut 3.3 110 77 11.1 Delaware 5.9 238 72 15.8 Florida 15.4 335 80 31.9 Georgia 17.4 211 60 25.8 Hawaii 5.3 46 83 20.2 Idaho 2.6 120 54 14.2 Illinois 10.4 249 83 24.0 Indiana 7.2 113 65 21.0 A data.frame: 6 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Vermont 2.2 48 32 11.2 Virginia 8.5 156 63 20.7 Washington 4.0 145 73 26.2 West Virginia 5.7 81 39 9.3 Wisconsin 2.6 53 66 10.8 Wyoming 6.8 161 60 15.6 Since we're using RStudio , we can see the information below easily. In case, we want to display those information in the console or compute with them, this is how it's done: ## size/summary of data # str short for structure # if you prefer to work with matrices: arrests = as.matrix(USArrests) str(arrests) num [1:50, 1:4] 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ... - attr(*, \"dimnames\")=List of 2 ..$ : chr [1:50] \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ... ..$ : chr [1:4] \"Murder\" \"Assault\" \"UrbanPop\" \"Rape\" Example 10 Summary statistics and basic visualization. summary(USArrests) Murder Assault UrbanPop Rape Min. : 0.800 Min. : 45.0 Min. :32.00 Min. : 7.30 1st Qu.: 4.075 1st Qu.:109.0 1st Qu.:54.50 1st Qu.:15.07 Median : 7.250 Median :159.0 Median :66.00 Median :20.10 Mean : 7.788 Mean :170.8 Mean :65.54 Mean :21.23 3rd Qu.:11.250 3rd Qu.:249.0 3rd Qu.:77.75 3rd Qu.:26.18 Max. :17.400 Max. :337.0 Max. :91.00 Max. :46.00 # extracting data USArrests[\"California\", \"Murder\"] USArrests[\"California\", ] USArrests[, \"Murder\"] USArrests$Murder 9 A data.frame: 1 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> California 9 276 91 40.6 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8 # to create a frequency histogram hist(USArrests[, \"Murder\"]) hist(USArrests$Murder) # to create a probability (relative frequency) histogram library(MASS) truehist(USArrests$Murder) hist(USArrests$Murder, prob=TRUE, breaks=\"scott\") USArrests$Murder .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8 Attaching a data frame # to save time, sometimes we attach a data frame so that we can use the # row/column names directly without the need of slicing or $ sign. attach(USArrests) # then we can call Murder instead of USArrests$Murder murder.pct = 100 * Murder / (Murder + Assault + Rape) # to detach detach(USArrests) Scatterplots and correlations attach(USArrests) plot(UrbanPop, Murder) pairs(USArrests) cor(UrbanPop, Murder) 0.0695726217359934 cor(USArrests) A matrix: 4 \u00d7 4 of type dbl Murder Assault UrbanPop Rape Murder 1.00000000 0.8018733 0.06957262 0.5635788 Assault 0.80187331 1.0000000 0.25887170 0.6652412 UrbanPop 0.06957262 0.2588717 1.00000000 0.4113412 Rape 0.56357883 0.6652412 0.41134124 1.0000000 Importing Data You can following tutorial for more detail: http://www.r-tutor.com/r-introduction/data-frame/data-import However, a quick way to import a csv file as a data frame in RStudio is as follows: 1. Download and know where the csv file is. 2. Use the read.csv() function, and put file.choose() as an argument. RStudio will open a window that will let you find the file you want to import. If your csv file has headers, then please also put the argument header=T into the read.csv() function. data <- read.csv(file.choose(), header=T) The most common error is you obtain only one column. The reason is usually that you didn't choose the correct delimiter (what character seperates the values in a row). By looking at the data frame, you can find out what delimiter was to be used. The common choices are: - ',' (comma) - ';' (semicolon) - '\\t' (tab) # to import a csv file with header, where the values in a row are seperated by tab: data = read.csv(file.choose(), sep='\\t', header = T)","title":"01 - Chapter 1"},{"location":"chapter_1_code_snippets/#getting-started","text":"We have seen most of the material below before. The examples below will provide good practice. Having written that, there are quite a number of new commands/ideas, as well.","title":"Getting Started"},{"location":"chapter_1_code_snippets/#example-1","text":"The purpose of this example is to get familiar how to create a vector using the combine c() function. Once you have a vector, arithmetic operations can be run using very simple syntax. You can make vectors algebraically interact with scalars (i.e. numbers) or with other vectors of same length (termwise). # create a vector and assign a variable. temps = c(51.9, 51.8, 51.9, 53) # subtract 32 from every item in the vector temps, and multiply the differences by 5/9, # that's the conversion formula from fahrenheit to celcius. (5/9) * (temps - 32) # create another vector. CT = c(48, 48.2, 48, 48.7) # when you subtract a vector from another, R runs the subtraction termwise. temps - CT .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 11.0555555555556 11 11.0555555555556 11.6666666666667 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 3.9 3.59999999999999 3.9 4.3","title":"Example 1"},{"location":"chapter_1_code_snippets/#example-2","text":"In this example, we practice indexing and slicing. By provoding the desired indices, we can grab the items at those indices of a vector. If we want to grab several items at once, the : operator comes very handy to generate a sequence of indices. The two new functions you may want to learn about would be the table() and barplot() functions. table() is used to create a frequency table. more on table() : https://www.statology.org/table-function-in-r/ more on barplot() : https://statisticsglobe.com/barplot-in-r # create two vectors from given data. winner = c(185, 182, 182, 188, 188, 188, 185, 185, 177, 182, 182, 193, 183, 179, 179, 175) opponent = c(175, 193, 185, 187, 188, 173, 180, 177, 183, 185, 180, 180, 182, 178, 178, 173) # you can see the lengths of the vectors in the environment pane of RStudio, # but you may want to compute with that length. # the `length()` function can be used to in those cases. length(winner) # `seq()` function is used to created a vector whose first item is 2008, last item 1948, # and the each item is 4 less than the previous item (i.e. the stepsize of the arithmetic sequence is -4) year = seq(from=2008, to=1948, by=-4) # grabbing the 4th item in the vector `winner`, # and updating that item with the value 189. winner[4] = 189 # grabbing the 5th item in the vector in `winner`, # and updating that item as 189. winner[5] = 189 # instead of the previous two commands, # we can grab the 4th and 5th items and update them with 189. winner[4:5] = 189 # the function `mean()` computes the mean (i.e. average) of a numerical vector. mean(winner) # the average of the `opponent` vector is computed. mean(opponent) # like in example 1, we can compute the difference of vectors (of same length), # that produces of a new vector whose items are the differences of the corresponding values in the given vectors. difference = winner - opponent # we create a data frame from the vectors `year`, `winner`, `opponent` and `difference` # those vectors will be columns of the data frame in the same order of the arguments of the function `data.frame()` data.frame(year, winner, opponent, difference) # the one below is a tricky line: # `winner > opponent` asks for every index of the vectors, if the item of `winner` vector is greater than # the correspondent item in the `opponent` vector. # the result of each of those comparisons is `TRUE` or `FALSE`. # hence `winner > opponent` creates a logical vector. # then that logical vector is assigned the variable name `taller.won` taller.won = winner > opponent # the `TRUE` and `FALSE`s are counted in the `taller.won` vector # the number of `TRUE`s is the the number of the elected president being taller than the other candidate. table(taller.won) # you can create the relative frequency (in percent) table by dividing each frequency by the total frequency # and multiplying by 100. table(taller.won) / 16 * 100 # finally a barplot is constructed. # one minor thing below: we want the values in the horizontal axis to increase as we move to right, # whereas our vectors constructed with election years in decreasing order. # 'rev(difference)' reverses the `difference` vector. # `barplot(rev(difference))` puts a bar at every index of the `rev(difference)` vector as tall as the value at that index. # `xlab` and `ylab` arguments of the `barplot()` function allow us name the x (horizontal) and y (vertical) axes. barplot(rev(difference), xlab=\"Election years 1948 to 2008\", ylab=\"Height difference in cm\") # note that the bars are not labed horizontally, # if you want horizontal labels, you can do the following: barplot(rev(difference), names.arg = rev(year), xlab=\"Election years 1948 to 2008\", ylab=\"Height difference in cm\") # depending on the size of the barplot, some horizontal labels can be skipped as R doesn't want the labels to overlap. # you can also easily draw a scatterplot for the pair of variables: `winner` and `opponent` # for every election, a point is generated whose x coordinate is the winner and y coordinate is the opponent. plot(winner,opponent) 16 183.4375 181.0625 A data.frame: 16 \u00d7 4 year winner opponent difference <dbl> <dbl> <dbl> <dbl> 2008 185 175 10 2004 182 193 -11 2000 182 185 -3 1996 189 187 2 1992 189 188 1 1988 188 173 15 1984 185 180 5 1980 185 177 8 1976 177 183 -6 1972 182 185 -3 1968 182 180 2 1964 193 180 13 1960 183 182 1 1956 179 178 1 1952 179 178 1 1948 175 173 2 taller.won FALSE TRUE 4 12 taller.won FALSE TRUE 25 75","title":"Example 2"},{"location":"chapter_1_code_snippets/#example-3","text":"In this example, deaths of Prussian soldiers due to horsekicks are studied (I know, we may not be the target audience.) Towards the end of the example, our data is compared to Poisson distribution, which models the probability of a given number of events occurring in a fixed interval of time, like what's the probability that your name is called a fixed number of times during a lecture. To learn more about Poisson distributions, you can take a look at the wikipedia page https://en.wikipedia.org/wiki/Poisson_distribution or these notes for a somewhat intuitive description. # first, the data is stored. # `k` stores the number of deaths # `x` stores the frequencies of the values in `k`. k = c(0, 1, 2, 3, 4) x = c(109, 65, 22, 3, 1) # first, we draw a barplot # remember that the first argument denotes the heights of the bars. # and that the `names.arg` argument in the `barplot` function allows us to specify our horizontal labels. # barplot(x, names.arg = k, ylab=\"Frequencies\", xlab = 'Number of deaths', main = 'Frequency distribution') # to get the relative frequency barplot, we simply divide the frequencies by the total frequency. # and produce a new bar plot using those heights (the name `p` stands for percentage, i suppose.) p = x / sum(x) barplot(p, names.arg=k, ylab='Relative Frequencies', xlab = 'Number of deaths', main = 'Relative Freq Distr') # remember that the mean is a weighted sum of relative frequencies, as we discussed in class # the way the sample mean `r` is computed below is as follows: # `p * k` computes the product of each horizontal value with the height of the corresponding bar. # then those little products are added. that way the sample mean is calculated. r = sum(p * k) # you can think of the variance as the square of the average error of a horizontal value from the mean. # i'll talk more about the variance and standard deviation in the class. v = sum(x * (k - r)^2) / 199 You may find the rest of the example a bit confusing. What's done below is: - First, using our sample mean, the probabilities are modeled using a Poisson distribution. Why Poisson? \"How many deaths per year\" is the kind of thing Poisson distributions model well. Also, Poisson distributions' mean equals their variance, and our sample mean and sample variance are pretty close, which can be taken as further evidence for using Poisson distributions to model our data. # model the theoretical probabilities using a Poisson distribution whose mean equals to our sample mean. # f denotes the relative frequencies (i.e. probabilities). f = r^k * exp(- r) / factorial(k) f .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 0.5433508690745 0.331444030135445 0.101090429191311 0.0205550539355665 0.00313464572517389 We can generate the Poisson distribution above using a built-in function of R . f = dpois(k, r) f .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 0.5433508690745 0.331444030135445 0.101090429191311 0.0205550539355665 0.00313464572517389 Then we multiply those theoretical relative frequencies generated by the Poisson distribution by 200 (our total frequency) and round the results down to get integer (theoretical) frequencies. floor(200*f) .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 108 66 20 4 0 Remember our actual frequencies: x .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 109 65 22 3 1 Note that our frequencies are pretty close to the theoretical frequencies of Poisson distribution with a mean that equals our sample mean, and when the sample size is 200 like ours. Lastly, we combine the vectors k (labels), p (our actual relative frequencies) and f (the theoretical relative frequencies) to see how good our sample data can be modeled by a Poission distribution. This is similar to the comparison of theoretical and our frequencies we did above, except at the relative frequency level. cbind(k, p, f) A matrix: 5 \u00d7 3 of type dbl k p f 0 0.545 0.543350869 1 0.325 0.331444030 2 0.110 0.101090429 3 0.015 0.020555054 4 0.005 0.003134646","title":"Example 3"},{"location":"chapter_1_code_snippets/#example-4","text":"The purpose of this example is to get familiar with using code snippets in R . One important takeaway from this example is to learn how to use R scripts in RStudio . If you choose File > New File > R Script in RStudio 's top menu and paste the following code snippet (a code snippet is a programming term that refers to a small portion of re-usable source code) into the pane on upper left corner and click the Source key, RStudio will run all the lines you pasted. You can save those code snippets in your hard-drive for future use. A good practice is to have a particular directory on your hard drive for those scripts, you name those files in a descriptive way when saving, you use the extension .R . Example: horsekicks.r One remark: When you want a variable to be displayed on console, you'll need to specify that you want it to be printed by using the print() function in your script. If you want to read more about the print() function: https://riptutorial.com/r/example/1221/printing-and-displaying-strings # Prussian horsekick data # rpois() generates random values according to the Poisson distribution and creates an artificially simulated sample. # we take the mean = .61 like in example 3, and sample size = 200. y = rpois(200, lambda=.61) # create a table of sample frequencies. kicks = table(y) # create a table of sample relative frequencies. sample = kicks / 200 # display the table of sample relative frequencies. print(sample) # create a theoretical relative distribution according to Poisson distribution with mean = 0.61 theoretical = dpois(0:3, lambda=.61) # display the theoretical relative frequencies. print(theoretical) # combine the theoretical and sample relative frequencies in a table: cbind(theoretical, Sample) # print the table print(cbind(theoretical, Sample)) y 0 1 2 3 4 0.525 0.320 0.130 0.020 0.005 [1] 0.54335087 0.33144403 0.10109043 0.02055505 A matrix: 4 \u00d7 2 of type dbl theoretical Sample 0 0.54335087 0.515 1 0.33144403 0.330 2 0.10109043 0.135 3 0.02055505 0.020 theoretical Sample 0 0.54335087 0.515 1 0.33144403 0.330 2 0.10109043 0.135 3 0.02055505 0.020 One interesting remark is that the actual data in example 3 fits the theoretical Poisson distribution better than the simulated data in example 4.","title":"Example 4"},{"location":"chapter_1_code_snippets/#the-r-help-system","text":"# to ask about a function/keyword. ?barplot # alternative way to ask about a function/keyword. help(barplot) # searches through the help documentation for the keyword and finds all the documentations that contain the keyword. ??dpois # searches through the help documentation for the keyword and finds all the documentations that contain the keyword. help.search(\"dpois\") # to get an example of how to use a function. example(mean) mean> x <- c(0:10, 50) mean> xm <- mean(x) mean> c(xm, mean(x, trim = 0.10)) [1] 8.75 5.50 # usually, there is an example at the end of the help file, as well. ?mean","title":"The R Help System"},{"location":"chapter_1_code_snippets/#functions","text":"","title":"Functions"},{"location":"chapter_1_code_snippets/#example-5","text":"In this example, defining and using a function are illustrated. We have discussed what functions are and how to define a function (the syntax of defining functions) last week. # defining the function whose name will be var.n # and which computes the sample variance of a vector of numbers. var.n = function(x){ v = var(x) n = NROW(x) v * (n - 1) / n } # using the function. temps = c(51.9, 51.8, 51.9, 53) var(temps) var.n(temps) 0.323333333333334 0.242500000000001","title":"Example 5"},{"location":"chapter_1_code_snippets/#example-6","text":"Omitted, because we don't need to discuss integration (a calculus operation) at this point.","title":"Example 6"},{"location":"chapter_1_code_snippets/#example-7","text":"The ( R ) function curve() which draws the graph of the (mathematical & R ) function in its argument. # remark: if the definition is one line { } are not needed. f = function(x, a=1, b=1) x^(a-1) * (1-x)^(b-1) # graphing a function from real numbers to real numbers. # remark: the function to be graphed should always be defined in terms of x. curve(f(x,2,5), from=0, to=1) # if you like, you can label the x and y axes. curve(f(x,2,5), from=0, to=1, xlab=\"inputs\", ylab='outputs')","title":"Example 7"},{"location":"chapter_1_code_snippets/#vectors-and-matrices","text":"","title":"Vectors and Matrices"},{"location":"chapter_1_code_snippets/#example-8","text":"Below, we create a matrix that represents the class mobility of generations. The entry $P_{ij}$ (namely, the entry in row $i$, column $j$) represents the probability the child being in the class represented by column $j$, if the parents are in row $i$. # creating a matrix from given data. probs = c(.45, .05, .01, .48, .70, .50, .07, .25, .49) P = matrix(probs, nrow=3, ncol=3) P # naming rows and columns. rownames(P) <- c(\"lower_old\", \"middle_old\", \"upper_old\") colnames(P) <- c(\"lower_new\", \"middle_new\", \"upper_new\") P # how to obtain row sums. rowSums(P) # how to obtain column sums. colSums(P) # grabbing the entry in row 1, column 3 P[1, 3] # grabbing the whole row 1 P[1, ] # grabbing the whole column 2 P[ ,2] A matrix: 3 \u00d7 3 of type dbl 0.45 0.48 0.07 0.05 0.70 0.25 0.01 0.50 0.49 A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.45 0.48 0.07 middle_old 0.05 0.70 0.25 upper_old 0.01 0.50 0.49 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_old 1 middle_old 1 upper_old 1 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_new 0.51 middle_new 1.68 upper_new 0.81 0.07 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_new 0.45 middle_new 0.48 upper_new 0.07 .dl-inline {width: auto; margin:0; padding: 0} .dl-inline>dt, .dl-inline>dd {float: none; width: auto; display: inline-block} .dl-inline>dt::after {content: \":\\0020\"; padding-right: .5ex} .dl-inline>dt:not(:first-of-type) {padding-left: .5ex} lower_old 0.48 middle_old 0.7 upper_old 0.5 # it's probably easier to define a matrix using the following command, # instead of typing two lines as above example. # `byrow=TRUE` argument guarantees that the numbers are placed in rows # and once sufficiently many numbers are placed, # the next number is placed as the first entry in the row below. Q = matrix(c( 0.45, 0.48, 0.07, 0.05, 0.70, 0.25, 0.01, 0.50, 0.49), nrow=3, ncol=3, byrow=TRUE) Q A matrix: 3 \u00d7 3 of type dbl 0.45 0.48 0.07 0.05 0.70 0.25 0.01 0.50 0.49 It's easy to do matrix operations in R . We probably won't need those operations, in case we do, I can go over basic matrix operations. But, here's the list anyways: (Ignore the operations that doesn't make sense to you.) # elementwise multiplication P * Q # exponentiating elementwise P^2 # matrix multiplication P %*% Q # inverse matrix solve(P) A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.2025 0.2304 0.0049 middle_old 0.0025 0.4900 0.0625 upper_old 0.0001 0.2500 0.2401 A matrix: 3 \u00d7 3 of type dbl lower_new middle_new upper_new lower_old 0.2025 0.2304 0.0049 middle_old 0.0025 0.4900 0.0625 upper_old 0.0001 0.2500 0.2401 A matrix: 3 \u00d7 3 of type dbl lower_old 0.2272 0.5870 0.1858 middle_old 0.0600 0.6390 0.3010 upper_old 0.0344 0.5998 0.3658 A matrix: 3 \u00d7 3 of type dbl lower_old middle_old upper_old lower_new 2.4549550 -2.254505 0.7995495 middle_new -0.2477477 2.475225 -1.2274775 upper_new 0.2027027 -2.479730 3.2770270","title":"Example 8"},{"location":"chapter_1_code_snippets/#data-frames","text":"Data frames are different from the matrices. The data type of entries of a matrix are all the same. You can think of a matrix as a 2D vector. On the other hand, a data frame consists of vertical vectors. Namely, each item in the same column has the same data type, but items in different columns don't have to have the same data type. It's like stacking vertical vectors horizontally.","title":"Data Frames"},{"location":"chapter_1_code_snippets/#example-9","text":"In this example, the purpose is to learn different ways of displaying a data frame and getting summary information of a data frame. # displaying all data USArrests A data.frame: 50 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 Connecticut 3.3 110 77 11.1 Delaware 5.9 238 72 15.8 Florida 15.4 335 80 31.9 Georgia 17.4 211 60 25.8 Hawaii 5.3 46 83 20.2 Idaho 2.6 120 54 14.2 Illinois 10.4 249 83 24.0 Indiana 7.2 113 65 21.0 Iowa 2.2 56 57 11.3 Kansas 6.0 115 66 18.0 Kentucky 9.7 109 52 16.3 Louisiana 15.4 249 66 22.2 Maine 2.1 83 51 7.8 Maryland 11.3 300 67 27.8 Massachusetts 4.4 149 85 16.3 Michigan 12.1 255 74 35.1 Minnesota 2.7 72 66 14.9 Mississippi 16.1 259 44 17.1 Missouri 9.0 178 70 28.2 Montana 6.0 109 53 16.4 Nebraska 4.3 102 62 16.5 Nevada 12.2 252 81 46.0 New Hampshire 2.1 57 56 9.5 New Jersey 7.4 159 89 18.8 New Mexico 11.4 285 70 32.1 New York 11.1 254 86 26.1 North Carolina 13.0 337 45 16.1 North Dakota 0.8 45 44 7.3 Ohio 7.3 120 75 21.4 Oklahoma 6.6 151 68 20.0 Oregon 4.9 159 67 29.3 Pennsylvania 6.3 106 72 14.9 Rhode Island 3.4 174 87 8.3 South Carolina 14.4 279 48 22.5 South Dakota 3.8 86 45 12.8 Tennessee 13.2 188 59 26.9 Texas 12.7 201 80 25.5 Utah 3.2 120 80 22.9 Vermont 2.2 48 32 11.2 Virginia 8.5 156 63 20.7 Washington 4.0 145 73 26.2 West Virginia 5.7 81 39 9.3 Wisconsin 2.6 53 66 10.8 Wyoming 6.8 161 60 15.6 # sometimes (and by sometimes i mean almost always) # there is too much data to display, # in those cases, displaying few top or bottom rows # is a good idea to see what kind of data we have. head(USArrests) # if you want to see more rows from top, you can specify that. head(USArrests, 14) # similarly, you can display few bottom rows, as well, # using the `tail()` function. tail(USArrests) A data.frame: 6 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 A data.frame: 14 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Alabama 13.2 236 58 21.2 Alaska 10.0 263 48 44.5 Arizona 8.1 294 80 31.0 Arkansas 8.8 190 50 19.5 California 9.0 276 91 40.6 Colorado 7.9 204 78 38.7 Connecticut 3.3 110 77 11.1 Delaware 5.9 238 72 15.8 Florida 15.4 335 80 31.9 Georgia 17.4 211 60 25.8 Hawaii 5.3 46 83 20.2 Idaho 2.6 120 54 14.2 Illinois 10.4 249 83 24.0 Indiana 7.2 113 65 21.0 A data.frame: 6 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> Vermont 2.2 48 32 11.2 Virginia 8.5 156 63 20.7 Washington 4.0 145 73 26.2 West Virginia 5.7 81 39 9.3 Wisconsin 2.6 53 66 10.8 Wyoming 6.8 161 60 15.6 Since we're using RStudio , we can see the information below easily. In case, we want to display those information in the console or compute with them, this is how it's done: ## size/summary of data # str short for structure # if you prefer to work with matrices: arrests = as.matrix(USArrests) str(arrests) num [1:50, 1:4] 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ... - attr(*, \"dimnames\")=List of 2 ..$ : chr [1:50] \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ... ..$ : chr [1:4] \"Murder\" \"Assault\" \"UrbanPop\" \"Rape\"","title":"Example 9"},{"location":"chapter_1_code_snippets/#example-10","text":"Summary statistics and basic visualization. summary(USArrests) Murder Assault UrbanPop Rape Min. : 0.800 Min. : 45.0 Min. :32.00 Min. : 7.30 1st Qu.: 4.075 1st Qu.:109.0 1st Qu.:54.50 1st Qu.:15.07 Median : 7.250 Median :159.0 Median :66.00 Median :20.10 Mean : 7.788 Mean :170.8 Mean :65.54 Mean :21.23 3rd Qu.:11.250 3rd Qu.:249.0 3rd Qu.:77.75 3rd Qu.:26.18 Max. :17.400 Max. :337.0 Max. :91.00 Max. :46.00 # extracting data USArrests[\"California\", \"Murder\"] USArrests[\"California\", ] USArrests[, \"Murder\"] USArrests$Murder 9 A data.frame: 1 \u00d7 4 Murder Assault UrbanPop Rape <dbl> <int> <int> <dbl> California 9 276 91 40.6 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8 .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8 # to create a frequency histogram hist(USArrests[, \"Murder\"]) hist(USArrests$Murder) # to create a probability (relative frequency) histogram library(MASS) truehist(USArrests$Murder) hist(USArrests$Murder, prob=TRUE, breaks=\"scott\") USArrests$Murder .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 5.3 2.6 10.4 7.2 2.2 6 9.7 15.4 2.1 11.3 4.4 12.1 2.7 16.1 9 6 4.3 12.2 2.1 7.4 11.4 11.1 13 0.8 7.3 6.6 4.9 6.3 3.4 14.4 3.8 13.2 12.7 3.2 2.2 8.5 4 5.7 2.6 6.8","title":"Example 10"},{"location":"chapter_1_code_snippets/#attaching-a-data-frame","text":"# to save time, sometimes we attach a data frame so that we can use the # row/column names directly without the need of slicing or $ sign. attach(USArrests) # then we can call Murder instead of USArrests$Murder murder.pct = 100 * Murder / (Murder + Assault + Rape) # to detach detach(USArrests)","title":"Attaching a data frame"},{"location":"chapter_1_code_snippets/#scatterplots-and-correlations","text":"attach(USArrests) plot(UrbanPop, Murder) pairs(USArrests) cor(UrbanPop, Murder) 0.0695726217359934 cor(USArrests) A matrix: 4 \u00d7 4 of type dbl Murder Assault UrbanPop Rape Murder 1.00000000 0.8018733 0.06957262 0.5635788 Assault 0.80187331 1.0000000 0.25887170 0.6652412 UrbanPop 0.06957262 0.2588717 1.00000000 0.4113412 Rape 0.56357883 0.6652412 0.41134124 1.0000000","title":"Scatterplots and correlations"},{"location":"chapter_1_code_snippets/#importing-data","text":"You can following tutorial for more detail: http://www.r-tutor.com/r-introduction/data-frame/data-import However, a quick way to import a csv file as a data frame in RStudio is as follows: 1. Download and know where the csv file is. 2. Use the read.csv() function, and put file.choose() as an argument. RStudio will open a window that will let you find the file you want to import. If your csv file has headers, then please also put the argument header=T into the read.csv() function. data <- read.csv(file.choose(), header=T) The most common error is you obtain only one column. The reason is usually that you didn't choose the correct delimiter (what character seperates the values in a row). By looking at the data frame, you can find out what delimiter was to be used. The common choices are: - ',' (comma) - ';' (semicolon) - '\\t' (tab) # to import a csv file with header, where the values in a row are seperated by tab: data = read.csv(file.choose(), sep='\\t', header = T)","title":"Importing Data"},{"location":"chapter_2/","text":"Chapter 2: Quantitive Data Bivariate Data: Two Quantitive (Numerical) Variables We start with importing a data set library called MASS . It contains the example we will be working with. # import the MASS data set library. library(MASS) This import will enlarge the data set examples in R . To see a list of new data sets that come with the MASS package, you can simply the following command. # list the data sets that come with MASS data(package = 'MASS') # list all data sets in `R` (the updated list) data() Example 1 In this example, we look at the mammals data set. # see how the data frame looks like by inspecting the first few rows. head(mammals) # how many rows and columns the data set contains. dim(mammals) After looking at the first few rows, and the dimension of the data frame, we see that the data set mammals contains body and brain sizes of 62 different mammal species. If you want to learn more about the data set mammals , you can check the documentation of the data set by simply typing ?mammals or help(mammals) . # if you want to learn more about the data set, you can check the documentation ?mammals To make sure the format of the data set you can type the following commands: # is the data set stored in a matrix? is.matrix(mammals) # is the data set stored in a data frame? is.data.frame(mammals) # or just ask for the class: data frame or matrix? class(mammals) # to see the answers of most of the questions above, you can simply type str(mammals) The command summary() summarizes each numerical column of the data frame and gives the frequency distributions of the categorical columns. summary(mammals) The problem with this data set is that the difference between the max and min is huge! Digression What are the smallest and largest animals in the mammals dataset? # which.min() gives the row number that contains the minimum of the column you specify # then to display that row, you can use the [] method mammals[which.min(mammals$body), ] mammals[which.max(mammals$body), ] Back to the example: To see a visualization of the 5-number-summary (min, Q1, median, Q2, max), we use boxplots. # to see the boxplot of each numerical column boxplot(mammals) The problem with this visualization is that the most of the mammals are relatively small, and to fit the bigger mammals into the graph, the boxplots are squeezed down all the way down. You can easy create scatter plots for every pair of variables (our dataset contains two variables body and brain hence there will be only one scatter plot). plot(mammals) Again, most of the points are squeezed down to the bottom left corner due to the existence of the very large mammals such as the elephant. What our textbook suggest is to using the logarithmic scale and see the order of magnitudes of the numbers. For those of you who don't remember much about logarithms: Digression: Logarithms The (natural) logarithm of a (positive) number $b$ is the power you need to raise the Euler number $e$ (which is an irrational number like $\\pi$ that happens to have very nice properties in math) to get $b$: $$\\log(a)= b \\leftrightarrow e^b = a$$ The Euler number $e$ has the approximate decimal value $2.7182$. To display $e$ in R : exp(1) What logarithm computes: log(1000) (exp(1))^6.907755279 # the error is due to rounding. $$\\log(1000)\\approx 6.908 \\leftrightarrow e^{6.908} \\approx 1000$$ You can think of $\\log(1000)$ as the number that tells how big 1000 is multiplicatively (when the standard/unit is taken to be the number $e\\approx 2.7182$.) Back to the example summary(log(mammals)) These numbers tell you how big the values are multiplicatively. This is a neat trick: If the numbers deviate a lot additively (i.e. max - min is too big), you may want to compare the numbers multiplicatively. plot(log(mammals), xlab=\"log(body)\", ylab=\"log(brain)\", las=1) boxplot(log(mammals)) Note that when you think of the numeric data in a multiplicative way, the visualizations look much better. One very important number that summarizes the relationship between two numberical variables is the (Pearson) correlation coefficient. It measures how strongly the values depend on each other: The (Pearson) correlation coefficient $r$ tells us two important things: The sign of the correlation coefficient between the variables tells us if the relation is positive or negative, i.e. if the second variable increases or decreases on average, when the first variable increases. The size of the correlation coefficient tells how strongly the variables are related. If the $|r|$ is close to 1, then the variables are strongly (linearly) related, and if $|r|$ is close to 0, then the strength of the relation between the variables is quite weak, if we can say there is a relation at all. cor(log(mammals)) Staying in the log-log scale, we see that brain and body variables have a correlation constant of 0.960, which is pretty close to 1. In other words, we can pretty accurately say, the larger the body size, the larger the brain size for mammals on average. (I know this sounds as a trivial observation, but think of the dinosaurs: dinosaur brain .) If there is a strong linear relation between two numeric variables (which we can find out by looking at the correlation coefficient of them), we can model that relation using a line (the simplest non-trivial model). # to simplify the prompts, first give log() values new names x = log(mammals$body) y = log(mammals$brain) # gives the best fitting line #when x is taken as the independent variable and y as the dependent variable lm(y ~ x) We can add the best-fit line to the scatter plot using the following lines: # creates short hand variable names for the columns. x = log(mammals$body) y = log(mammals$brain) # draws the scatter plot of x versus y. plot(x, y, xlab=\"log(body)\", ylab=\"log(brain)\", las=1) # abline() adds a straight line to the plot, # the line we want to add is the linear model, so we use lm(). abline(lm(y ~ x)) --- Example 2 The data set of this example comes from the package \"UsingR\". To see more about that package: UsingR First, we need to install this package. # you install a package only once install.packages(\"UsingR\") Then we need to import the package (i.e. tell R that we will use it in the session). # you import a package every time you restart rstudio library(UsingR) twins is a data frame that comes with that package. str(twins) 'data.frame': 27 obs. of 3 variables: $ Foster : num 82 80 88 108 116 117 132 71 75 93 ... $ Biological: num 82 90 91 115 115 129 131 78 79 82 ... $ Social : Factor w/ 3 levels \"high\",\"low\",\"middle\": 1 1 1 1 1 1 1 3 3 3 ... head(twins) A data.frame: 6 \u00d7 3 Foster Biological Social <dbl> <dbl> <fct> 1 82 82 high 2 80 90 high 3 88 91 high 4 108 115 high 5 116 115 high 6 117 129 high summary(twins) Foster Biological Social Min. : 63.00 Min. : 68.0 high : 7 1st Qu.: 84.50 1st Qu.: 83.5 low :14 Median : 94.00 Median : 94.0 middle: 6 Mean : 95.11 Mean : 95.3 3rd Qu.:107.50 3rd Qu.:104.5 Max. :132.00 Max. :131.0 Actually, this is quite a controversial data set https://www.intelltheory.com/burtaffair.shtml The data set has 3 variables (3 columns). 27 twins are studied. They were seperated at birth. One kid is raised in a foster family. One The Foster column contains the IQ of the child whoraised in the foster family, Biological column contains the IQ level of the child that is raised in his/her biological family. Social is a categorical variable that tells about the social status of the biological parents (high, middle or low). An interesting data visualization is the difference between the IQ levels of the identical twins (one raised in a foster family and the other one is raised in the biological family). boxplot(twins$Foster - twins$Biological) This boxplot looks symmetric. But a more interesting visualization would be that IQ difference versus the social status of the biological parents. The ~ in the (Foster - Biological) ~ Social stands for versus . The second variable is taken to be the independent variable (x-axis) and the first variable is taken to be the dependent variable (y-axis). Since the Social is a categorical variable, the values for it are discrete: low , middle high . # takes the twins dataset # takes Social as the horizontal variable # takes Foster - Biological as the vertical variable # draws boxplots for different values of the horizontal variable \"Social\" boxplot((Foster-Biological) ~ Social, twins) Similarly, we can draw a scatterplot without detailing by the Social values: plot(twins$Foster, twins$Biological) A better visualization is when we take the values of the Social into account. plot(Foster ~ Biological, data=twins, pch=status, col=`Social`) legend(\"topleft\", c(\"high\",\"low\",\"middle\"), pch=1:3, col=1:3, inset=.02) abline(0,1) coplot(Foster ~ Biological | Social, data = twins) xyplot(Foster ~ Biological|Social, data=twins) xyplot(Foster ~ Biological|Social, data=twins, pch=20, col=1)","title":"02 - Chapter 2"},{"location":"chapter_2/#chapter-2-quantitive-data","text":"","title":"Chapter 2: Quantitive Data"},{"location":"chapter_2/#bivariate-data-two-quantitive-numerical-variables","text":"We start with importing a data set library called MASS . It contains the example we will be working with. # import the MASS data set library. library(MASS) This import will enlarge the data set examples in R . To see a list of new data sets that come with the MASS package, you can simply the following command. # list the data sets that come with MASS data(package = 'MASS') # list all data sets in `R` (the updated list) data()","title":"Bivariate Data: Two Quantitive (Numerical) Variables"},{"location":"chapter_2/#example-1","text":"In this example, we look at the mammals data set. # see how the data frame looks like by inspecting the first few rows. head(mammals) # how many rows and columns the data set contains. dim(mammals) After looking at the first few rows, and the dimension of the data frame, we see that the data set mammals contains body and brain sizes of 62 different mammal species. If you want to learn more about the data set mammals , you can check the documentation of the data set by simply typing ?mammals or help(mammals) . # if you want to learn more about the data set, you can check the documentation ?mammals To make sure the format of the data set you can type the following commands: # is the data set stored in a matrix? is.matrix(mammals) # is the data set stored in a data frame? is.data.frame(mammals) # or just ask for the class: data frame or matrix? class(mammals) # to see the answers of most of the questions above, you can simply type str(mammals) The command summary() summarizes each numerical column of the data frame and gives the frequency distributions of the categorical columns. summary(mammals) The problem with this data set is that the difference between the max and min is huge!","title":"Example 1"},{"location":"chapter_2/#digression","text":"What are the smallest and largest animals in the mammals dataset? # which.min() gives the row number that contains the minimum of the column you specify # then to display that row, you can use the [] method mammals[which.min(mammals$body), ] mammals[which.max(mammals$body), ]","title":"Digression"},{"location":"chapter_2/#back-to-the-example","text":"To see a visualization of the 5-number-summary (min, Q1, median, Q2, max), we use boxplots. # to see the boxplot of each numerical column boxplot(mammals) The problem with this visualization is that the most of the mammals are relatively small, and to fit the bigger mammals into the graph, the boxplots are squeezed down all the way down. You can easy create scatter plots for every pair of variables (our dataset contains two variables body and brain hence there will be only one scatter plot). plot(mammals) Again, most of the points are squeezed down to the bottom left corner due to the existence of the very large mammals such as the elephant. What our textbook suggest is to using the logarithmic scale and see the order of magnitudes of the numbers. For those of you who don't remember much about logarithms:","title":"Back to the example:"},{"location":"chapter_2/#digression-logarithms","text":"The (natural) logarithm of a (positive) number $b$ is the power you need to raise the Euler number $e$ (which is an irrational number like $\\pi$ that happens to have very nice properties in math) to get $b$: $$\\log(a)= b \\leftrightarrow e^b = a$$ The Euler number $e$ has the approximate decimal value $2.7182$. To display $e$ in R : exp(1) What logarithm computes: log(1000) (exp(1))^6.907755279 # the error is due to rounding. $$\\log(1000)\\approx 6.908 \\leftrightarrow e^{6.908} \\approx 1000$$ You can think of $\\log(1000)$ as the number that tells how big 1000 is multiplicatively (when the standard/unit is taken to be the number $e\\approx 2.7182$.)","title":"Digression: Logarithms"},{"location":"chapter_2/#back-to-the-example_1","text":"summary(log(mammals)) These numbers tell you how big the values are multiplicatively. This is a neat trick: If the numbers deviate a lot additively (i.e. max - min is too big), you may want to compare the numbers multiplicatively. plot(log(mammals), xlab=\"log(body)\", ylab=\"log(brain)\", las=1) boxplot(log(mammals)) Note that when you think of the numeric data in a multiplicative way, the visualizations look much better. One very important number that summarizes the relationship between two numberical variables is the (Pearson) correlation coefficient. It measures how strongly the values depend on each other: The (Pearson) correlation coefficient $r$ tells us two important things: The sign of the correlation coefficient between the variables tells us if the relation is positive or negative, i.e. if the second variable increases or decreases on average, when the first variable increases. The size of the correlation coefficient tells how strongly the variables are related. If the $|r|$ is close to 1, then the variables are strongly (linearly) related, and if $|r|$ is close to 0, then the strength of the relation between the variables is quite weak, if we can say there is a relation at all. cor(log(mammals)) Staying in the log-log scale, we see that brain and body variables have a correlation constant of 0.960, which is pretty close to 1. In other words, we can pretty accurately say, the larger the body size, the larger the brain size for mammals on average. (I know this sounds as a trivial observation, but think of the dinosaurs: dinosaur brain .) If there is a strong linear relation between two numeric variables (which we can find out by looking at the correlation coefficient of them), we can model that relation using a line (the simplest non-trivial model). # to simplify the prompts, first give log() values new names x = log(mammals$body) y = log(mammals$brain) # gives the best fitting line #when x is taken as the independent variable and y as the dependent variable lm(y ~ x) We can add the best-fit line to the scatter plot using the following lines: # creates short hand variable names for the columns. x = log(mammals$body) y = log(mammals$brain) # draws the scatter plot of x versus y. plot(x, y, xlab=\"log(body)\", ylab=\"log(brain)\", las=1) # abline() adds a straight line to the plot, # the line we want to add is the linear model, so we use lm(). abline(lm(y ~ x))","title":"Back to the example"},{"location":"chapter_2/#-","text":"","title":"---"},{"location":"chapter_2/#example-2","text":"The data set of this example comes from the package \"UsingR\". To see more about that package: UsingR First, we need to install this package. # you install a package only once install.packages(\"UsingR\") Then we need to import the package (i.e. tell R that we will use it in the session). # you import a package every time you restart rstudio library(UsingR) twins is a data frame that comes with that package. str(twins) 'data.frame': 27 obs. of 3 variables: $ Foster : num 82 80 88 108 116 117 132 71 75 93 ... $ Biological: num 82 90 91 115 115 129 131 78 79 82 ... $ Social : Factor w/ 3 levels \"high\",\"low\",\"middle\": 1 1 1 1 1 1 1 3 3 3 ... head(twins) A data.frame: 6 \u00d7 3 Foster Biological Social <dbl> <dbl> <fct> 1 82 82 high 2 80 90 high 3 88 91 high 4 108 115 high 5 116 115 high 6 117 129 high summary(twins) Foster Biological Social Min. : 63.00 Min. : 68.0 high : 7 1st Qu.: 84.50 1st Qu.: 83.5 low :14 Median : 94.00 Median : 94.0 middle: 6 Mean : 95.11 Mean : 95.3 3rd Qu.:107.50 3rd Qu.:104.5 Max. :132.00 Max. :131.0 Actually, this is quite a controversial data set https://www.intelltheory.com/burtaffair.shtml The data set has 3 variables (3 columns). 27 twins are studied. They were seperated at birth. One kid is raised in a foster family. One The Foster column contains the IQ of the child whoraised in the foster family, Biological column contains the IQ level of the child that is raised in his/her biological family. Social is a categorical variable that tells about the social status of the biological parents (high, middle or low). An interesting data visualization is the difference between the IQ levels of the identical twins (one raised in a foster family and the other one is raised in the biological family). boxplot(twins$Foster - twins$Biological) This boxplot looks symmetric. But a more interesting visualization would be that IQ difference versus the social status of the biological parents. The ~ in the (Foster - Biological) ~ Social stands for versus . The second variable is taken to be the independent variable (x-axis) and the first variable is taken to be the dependent variable (y-axis). Since the Social is a categorical variable, the values for it are discrete: low , middle high . # takes the twins dataset # takes Social as the horizontal variable # takes Foster - Biological as the vertical variable # draws boxplots for different values of the horizontal variable \"Social\" boxplot((Foster-Biological) ~ Social, twins) Similarly, we can draw a scatterplot without detailing by the Social values: plot(twins$Foster, twins$Biological) A better visualization is when we take the values of the Social into account. plot(Foster ~ Biological, data=twins, pch=status, col=`Social`) legend(\"topleft\", c(\"high\",\"low\",\"middle\"), pch=1:3, col=1:3, inset=.02) abline(0,1) coplot(Foster ~ Biological | Social, data = twins) xyplot(Foster ~ Biological|Social, data=twins) xyplot(Foster ~ Biological|Social, data=twins, pch=20, col=1)","title":"Example 2"},{"location":"homework/","text":"Homework Assignments Instructions Every week, you'll be paired up with another colleague of yours. And each pair has two tasks: - Do the assigned problems. - Give feedback to another pair (making corrections and asking for/suggesting clarifications and even suggesting a better approach). Homework 2 Teams Team number Members of the team Gives feedback to the team Which HW problems to solve 1 Tatiana & Daniela 7 3, 5 2 Emma & Kate 1 2, 1 3 Dekeiya & Ritchele 2 6, 7 4 Kristen & Mallory 3 4, 3 5 Venus & Deirdre 4 5, 2 6 Hannah & Jasmine 5 1, 6 7 Fariha & Sema 6 7, 4 # for those who are interested, this is how i randomized the hw assignments for each team set.seed(13) # setting a seed makes a randomization process reproducible problems <- 1:7 # creates a vector (1,2,3,4,5,6,7) problems_shuffled <- sample(problems) # samples from problems vector, i.e. picks 7 numbers from problems randomly rep(problems_shuffled,2) # since there are 14 students and 7 problems, i duplicated the shuffled problem numbers .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 3 5 2 1 6 7 4 3 5 2 1 6 7 4 Due dates Tuesday, June 21, 11:59pm: Finish your problems and send your solutions both to me and to a member of the supervisor team. Thursday, June 23, 11:59pm: Finish evaluating the other pair's solutions and send you feedback to me and back to a member of the other team. Problems To be announced. Homework 1 The purpose of this week's hw is to make sure the following arrangement works and you find ways to communicate (e.g. private Telegram chats). Teams and their tasks Task one is doing the problems and writing R code and saving the results on a file. The file can be a MS Word file, it can be an R script created in RStudio that contains comment lines explaining the work. Or some other reasonable way where the supervisor team can read, replicate (if necessary) and understand the work. Then the supervisor team looks at the work (put yourselves into my shoes, you're active teachers, hence you know how to evaluate work). If your supervising the work of another team, you're expected to be as critical as possible. Ask questions like \"Is it clarified why this step is taken?\" or \"Why is this variable created? It's not used later.\" or more serious issues like, \"The data frame is wrong, the second columns should've been inverted.\" Let me make something clear, don't worry about the grades, it's all about producing good solutions. Try to produce your best work (with nice explanations to make the supervising team's life easy and to impress them) and as a supervisor team, try to give as much feedback as possible and improve the quality of the solution (which includes clarifying claims and correcting mistakes). Team number Members of the team Gives feedback to the team Which HW problems to solve 1 Tatiana & Emma 7 1, 5 2 Dekeiya & Kristen 1 7, 6 3 Venus & Hannah 2 2, 3 4 Fariha & Mallory 3 4, 1 5 Deirdre & Jasmine 4 5, 7 6 Sema & Daniela 5 6, 2 7 Kate & Ritchele 6 3, 4 # for those who are interested, this is how i randomized the hw assignments for each team set.seed(42) # setting a seed makes a randomization process reproducible problems <- 1:7 # creates a vector (1,2,3,4,5,6,7) problems_shuffled <- sample(problems) # samples from problems vector, i.e. picks 7 numbers from problems randomly rep(problems_shuffled,2) # since there are 14 students and 7 problems, i duplicated the shuffled problem numbers .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 1 5 7 6 2 3 4 1 5 7 6 2 3 4 Due dates Tuesday, June 14, 11:59pm: Finish your problems and send your solutions both to me and to a member of the supervisor team. Thursday, June 16, 11:59pm: Finish evaluating the other pair's solutions and send you feedback to me and back to a member of the other team. Let me give a few hypothetical examples (The teams and the problem assignments are accurate except the last example): - Team 3 does problems 2 and 3. Team 4 supervises team 3. Venus does problem 2, Hannah does problem 3. They take a look at each other's solutions and make sure everything is right before sending them to the supervisor pair (which is team 4). Team 4 looks at the solutions and writes as feedback that one of the graphs doesn't look nice, because the horizontal values are not clear (maybe no labeling), questions the fact that it's not clear where the data comes from, comments that the results are not clearly written. Team 7 does problems 3 and 4. Kate missed the relevant lectures, because she had to save someone in the school library who was having a heart attack. Ritchele being a great person does both of those problems and even explains her solutions to Kate. Kate brings the super expensive chocolate box she received from the person who she saved to Ritchele and lets her to take a few chocolate pieces. Team 1 (being the supervising team) writes the mean is used instead of the median even when the data is quite skew-symmetric and has outliers. Jack in team 12 hates this course. Mike in team 12 went for a vacation. They didn't do the homework. Beyonce and Sting in team 13 do the problems of team 12 because they are perfect. Team 13 gets highly deserved appreciation for that by me and the classmates, we applaud their diligent work in class. Problems Pick any data set that comes with R , describe what the data set contains shortly. Pick a numerical column. Compute the mean and standard deviation of that column. Draw a bar graph/histogram for that column. Draw a bar graph that has only one bar located at the mean (of the chose column). Draw a bar chart that has two bars of height 0.5 located at \"mean - standard deviation\" and \"mean + standard deviation\". Either finish reading chapter 1 and pick an example we didn't discuss in class yet. Explain what makes that example interesting for you. And summarize/comment on the takeaways from that example. Or pick any exercise at the end of chapter 1. Explain the question and your answer to someone who missed the first few lectures of our course. Create a data frame that contains some fake data: A question is asked twice to 20 people and the possible answers are 0, 1, 2, 3. Create two vectors that contain the answers of when the question asked the first time and when the question is asked the second time. Draw the results on two different bar charts. Then find out how to draw the bars together in one bar chart (google the phrase \"stacked bar graph\"). Describe what the difference between a matrix and a data frame. Give an instructive example using numbers and text you pick. Do a few things with that matrix and the data frame (e.g. compute the mean of a column, display the first two rows etc.). Learn and explain how to import a (comma-seperated-values) csv file into a data frame in R . Find a csv file online (just google for csv example or look at this website: https://wsform.com/knowledgebase/sample-csv-files/ ). Download the file to your computer. Then use RStudio to import the file. Explain shortly what Euclidean norm is and write a function that computes the Euclidean length (norm) of a vector (exc 1.10 in the textbook). ~Explain the difference between bar plots and histograms. Give examples for each that illustrates the difference. You can pick columns from data sets that come with R , or go with numbers you arbitrarily pick.~ Nah, do exercise 1.14 in chapter 1 instead.","title":"Homework"},{"location":"homework/#homework-assignments","text":"","title":"Homework Assignments"},{"location":"homework/#instructions","text":"Every week, you'll be paired up with another colleague of yours. And each pair has two tasks: - Do the assigned problems. - Give feedback to another pair (making corrections and asking for/suggesting clarifications and even suggesting a better approach).","title":"Instructions"},{"location":"homework/#homework-2","text":"","title":"Homework 2"},{"location":"homework/#teams","text":"Team number Members of the team Gives feedback to the team Which HW problems to solve 1 Tatiana & Daniela 7 3, 5 2 Emma & Kate 1 2, 1 3 Dekeiya & Ritchele 2 6, 7 4 Kristen & Mallory 3 4, 3 5 Venus & Deirdre 4 5, 2 6 Hannah & Jasmine 5 1, 6 7 Fariha & Sema 6 7, 4 # for those who are interested, this is how i randomized the hw assignments for each team set.seed(13) # setting a seed makes a randomization process reproducible problems <- 1:7 # creates a vector (1,2,3,4,5,6,7) problems_shuffled <- sample(problems) # samples from problems vector, i.e. picks 7 numbers from problems randomly rep(problems_shuffled,2) # since there are 14 students and 7 problems, i duplicated the shuffled problem numbers .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 3 5 2 1 6 7 4 3 5 2 1 6 7 4","title":"Teams"},{"location":"homework/#due-dates","text":"Tuesday, June 21, 11:59pm: Finish your problems and send your solutions both to me and to a member of the supervisor team. Thursday, June 23, 11:59pm: Finish evaluating the other pair's solutions and send you feedback to me and back to a member of the other team.","title":"Due dates"},{"location":"homework/#problems","text":"To be announced.","title":"Problems"},{"location":"homework/#homework-1","text":"The purpose of this week's hw is to make sure the following arrangement works and you find ways to communicate (e.g. private Telegram chats).","title":"Homework 1"},{"location":"homework/#teams-and-their-tasks","text":"Task one is doing the problems and writing R code and saving the results on a file. The file can be a MS Word file, it can be an R script created in RStudio that contains comment lines explaining the work. Or some other reasonable way where the supervisor team can read, replicate (if necessary) and understand the work. Then the supervisor team looks at the work (put yourselves into my shoes, you're active teachers, hence you know how to evaluate work). If your supervising the work of another team, you're expected to be as critical as possible. Ask questions like \"Is it clarified why this step is taken?\" or \"Why is this variable created? It's not used later.\" or more serious issues like, \"The data frame is wrong, the second columns should've been inverted.\" Let me make something clear, don't worry about the grades, it's all about producing good solutions. Try to produce your best work (with nice explanations to make the supervising team's life easy and to impress them) and as a supervisor team, try to give as much feedback as possible and improve the quality of the solution (which includes clarifying claims and correcting mistakes). Team number Members of the team Gives feedback to the team Which HW problems to solve 1 Tatiana & Emma 7 1, 5 2 Dekeiya & Kristen 1 7, 6 3 Venus & Hannah 2 2, 3 4 Fariha & Mallory 3 4, 1 5 Deirdre & Jasmine 4 5, 7 6 Sema & Daniela 5 6, 2 7 Kate & Ritchele 6 3, 4 # for those who are interested, this is how i randomized the hw assignments for each team set.seed(42) # setting a seed makes a randomization process reproducible problems <- 1:7 # creates a vector (1,2,3,4,5,6,7) problems_shuffled <- sample(problems) # samples from problems vector, i.e. picks 7 numbers from problems randomly rep(problems_shuffled,2) # since there are 14 students and 7 problems, i duplicated the shuffled problem numbers .list-inline {list-style: none; margin:0; padding: 0} .list-inline>li {display: inline-block} .list-inline>li:not(:last-child)::after {content: \"\\00b7\"; padding: 0 .5ex} 1 5 7 6 2 3 4 1 5 7 6 2 3 4","title":"Teams and their tasks"},{"location":"homework/#due-dates_1","text":"Tuesday, June 14, 11:59pm: Finish your problems and send your solutions both to me and to a member of the supervisor team. Thursday, June 16, 11:59pm: Finish evaluating the other pair's solutions and send you feedback to me and back to a member of the other team. Let me give a few hypothetical examples (The teams and the problem assignments are accurate except the last example): - Team 3 does problems 2 and 3. Team 4 supervises team 3. Venus does problem 2, Hannah does problem 3. They take a look at each other's solutions and make sure everything is right before sending them to the supervisor pair (which is team 4). Team 4 looks at the solutions and writes as feedback that one of the graphs doesn't look nice, because the horizontal values are not clear (maybe no labeling), questions the fact that it's not clear where the data comes from, comments that the results are not clearly written. Team 7 does problems 3 and 4. Kate missed the relevant lectures, because she had to save someone in the school library who was having a heart attack. Ritchele being a great person does both of those problems and even explains her solutions to Kate. Kate brings the super expensive chocolate box she received from the person who she saved to Ritchele and lets her to take a few chocolate pieces. Team 1 (being the supervising team) writes the mean is used instead of the median even when the data is quite skew-symmetric and has outliers. Jack in team 12 hates this course. Mike in team 12 went for a vacation. They didn't do the homework. Beyonce and Sting in team 13 do the problems of team 12 because they are perfect. Team 13 gets highly deserved appreciation for that by me and the classmates, we applaud their diligent work in class.","title":"Due dates"},{"location":"homework/#problems_1","text":"Pick any data set that comes with R , describe what the data set contains shortly. Pick a numerical column. Compute the mean and standard deviation of that column. Draw a bar graph/histogram for that column. Draw a bar graph that has only one bar located at the mean (of the chose column). Draw a bar chart that has two bars of height 0.5 located at \"mean - standard deviation\" and \"mean + standard deviation\". Either finish reading chapter 1 and pick an example we didn't discuss in class yet. Explain what makes that example interesting for you. And summarize/comment on the takeaways from that example. Or pick any exercise at the end of chapter 1. Explain the question and your answer to someone who missed the first few lectures of our course. Create a data frame that contains some fake data: A question is asked twice to 20 people and the possible answers are 0, 1, 2, 3. Create two vectors that contain the answers of when the question asked the first time and when the question is asked the second time. Draw the results on two different bar charts. Then find out how to draw the bars together in one bar chart (google the phrase \"stacked bar graph\"). Describe what the difference between a matrix and a data frame. Give an instructive example using numbers and text you pick. Do a few things with that matrix and the data frame (e.g. compute the mean of a column, display the first two rows etc.). Learn and explain how to import a (comma-seperated-values) csv file into a data frame in R . Find a csv file online (just google for csv example or look at this website: https://wsform.com/knowledgebase/sample-csv-files/ ). Download the file to your computer. Then use RStudio to import the file. Explain shortly what Euclidean norm is and write a function that computes the Euclidean length (norm) of a vector (exc 1.10 in the textbook). ~Explain the difference between bar plots and histograms. Give examples for each that illustrates the difference. You can pick columns from data sets that come with R , or go with numbers you arbitrarily pick.~ Nah, do exercise 1.14 in chapter 1 instead.","title":"Problems"},{"location":"intro_to_r/","text":"Lecture 1: Preliminaries R and RStudio R is a statistical computing environment: open source and free software for statistical computation and graphics and a computer language designed for typical statistical and graphical applications R is an interpreted language: You type some commands (via at terminal/command prompt or from a file called a script), and R processes those commands. In this course, we will use RStudio to interact with R . RStudio is an integrated development environment, in other words user friendly software to interact with a language. How to install R and RStudio You can install R from: The Comprehensive R Archive Network You can install RStudio from: Download the RStudio IDE - RStudio Here's a webpage that explains the installation process in steps for different operating systems: Install R and RStudio - A Step-by-Step Guide for Beginners - TechVidvan Here's a Youtube tutorial for MacOS: How to install R and RStudio on Mac - YouTube Here's a Youtube tutorial for Windows: How to download and install R and RStudio - YouTube Basic calculations in R You can use R as a calculator and let it process a one line operation: 1+2 3 Here's a tidy website that contains a list of useful operators: R Operators - Learn By Example In this course, we'll be doing more complex computations and we'll need to save the result of a computation to be used later in some other computation. For that reason, we have variables . You can think of a variable as a keyword you chose to store a particular piece of information (numerical, or text or even logical). In R , there are two ways to assign a value to a variable: using = and using <- First you type the name of the variable you chose, then you type = or <- and then you put what value you want to assign to that variable. That value can be the result of some calculation, can be the output of some function, it can be a number or text or logical value you want to store. # note that, when you make an assignment, you don't get an output. # if you're using RStudio, the variable and its value can be seen in the Environment pane a = 3 ^ 2 #(example: exponentiation) # if you want R to return the value of a variable to the console, you'll need to type the name a 9 b <- 8 %/% 3 #(example: integer division) b 2 # you can see the variables in RStudio in a nice, organized way in the Environment pane # but if you want to see a list of variables in the Console: ls() 'a' 'b' Note that R is case sensitive, for example a and A are treated as different variable names. A = 7 a 9 A 7 If you want to update the value of a variable, you can do that of course. A = 10 # now the value of A is not 7 anymore, but 10. A 10 Basic Data Types in R Here's a nice reference for more on basic data types and data structures in R : https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/ There are 6 data types in R : character numeric (real or decimal) integer logical complex You can find out the type of an object using the typeof() function. We'll discuss functions below, but basically they are self-contained algorithms built to perform a specific task. A function expects a user to give arguments as input and based on the values of the arguments, a function produces an output. # character values are anything that is to be treated as text typeof(\"ab\") 'character' In the example above, we gave \"ab\" as the input to the function typeof() by typing \"ab\" between the parentheses, and the typeof() function returned us the type of \"ab\" as the output. # R will decide how to store the value unless you specify the data type manually typeof(2) 'double' (If you wonder why the word 'double', double just means a decimal number in double precision, i.e. two decimals after the decimal point.) # by using '' or \"\", we can tell R that we're using a characters typeof('2') 'character' You can store text in a variable as well. To store a text value, you'll need to use \" or ' . Otherwise, R thinks you're typing the name of a variable. # note the the ' signs between the \" signs are treated as apostrophes: mytext <- \"I'm having a great 'day' today.\" mytext 'I\\'m having a great \\'day\\' today.' The backslash before the apostrophe \\' is R 's way of remembering that ' sign is to be treated as an apostrophe, but not as a delimiter of some text data. # the backslashes above are to denote escape sequences # \\' tells R to treat the apostrophe as a character # to print nicely, you can use the cat() function cat(mytext) I'm having a great 'day' today. typeof(2L) # the L on the right tells R to store 2 as an integer 'integer' typeof(-12.4) 'double' typeof(T) 'logical' typeof(FALSE) 'logical' typeof(1+4i) 'complex' Basic Data Structures in R Data structures are ways to store (usually multiple) values together in a specific way. R has multiple data structures. The most important ones for us include: atomic vector list matrix data frame factors # you can think of vectors as lists/arrays # that contain items of the same type # the function c() below combines items to create vectors vec1 <- c(1,2,3,20,3) vec2 <- c(T,T,F,F,FALSE, TRUE) vec3 <- c('a','stats', '614', \"\\'\") vec4 <- c(2L, -5L) vec5 <- 1:10 length(vec1) 5 typeof(vec2) 'logical' typeof(vec3) 'character' cat(vec4) 2 -5 2*vec4 4 -10 vec5 1 2 3 4 5 6 7 8 9 10 vec6 <- vec5 - vec5 vec6 0 0 0 0 0 0 0 0 0 0 vec4 + vec6 2 -5 2 -5 2 -5 2 -5 2 -5 vec7 <- c(1,2,3) typeof(vec7) 'double' vec8 <- c(1L,2L,3L) typeof(vec8) 'integer' # in R, == means comparing and asking if the items are equal vec7 == vec8 TRUE TRUE TRUE # the str() function compactly displayes the internal STRucture of an R object # rdocumentation.org/packages/utils/versions/3.6.2/topics/str str(vec8) int [1:3] 1 2 3 How to add a new element # below, i'm combining vec8 and the number 4 as an integer, # the number 4 is appended on the right, # hence the last item of vec9 is 4 vec9 <- c(vec8,4L) vec9 1 2 3 4 # below, the number zero is appended to vec9 on the left, # i.e. the first item in vec10 is 0 vec10 <- c(0L,vec9) vec10 0 1 2 3 4 How to create vectors from a sequence of numbers # the 1:10 command creates a sequence of integers that start at 1 and end at 10 vec11 <- 1:10 vec11 1 2 3 4 5 6 7 8 9 10 # you can create sequences more directly using the seq() function # you specify where the sequence of numbers start, end and the stepsize. vec12 <- seq(from = 1, to = 2, by = 0.1) vec12 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 # if the stepsize is not given, the default stepsize is used, which is 1. vec12 <- seq(from = 1, to = 20) vec12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Factors Factors are categorical variables in R . We'll talk about categorical variables and factors later, but as foreshadowing, we can use categorical variables to create hierarchies in the sense that we can compute the mean age of everyone, and at a detailed level, we can compute the mean age of female and male people using \"Female\" and \"Male\" categories. vec13 = as.factor(c(\"Male\", \"Female\", \"Male\", \"Female\")) vec13 Male Female Male Female Levels : 'Female' 'Male' # note that R automatically decides what the underlying data type is when creating a vector # the items in a vector need to be of the same data type. vec14 = c(1,TRUE,'A') class(vec14) 'character' Lists # what if we want to store items of different data types and keep the data types as they are? # we use lists mylist <- list(1,TRUE,'A') mylist 1 TRUE 'A' typeof(mylist) 'list' mylist2 <- list(mylist, c(1,2,3)) mylist2 1 TRUE 'A' 1 2 3 mylist3 <- c(mylist, c(1,2,3)) mylist3 1 TRUE 'A' 1 2 3 Data Frames You can think of data frames as lists of vectors of equal length forming columns. Or even better, like a spreadsheet. # to create a data frame from vectors, you can use the data.frame() function data.frame(vec1,vec2,vec3) Error in data.frame(vec1, vec2, vec3): arguments imply differing number of rows: 5, 6, 4 Traceback: 1. data.frame(vec1, vec2, vec3) 2. stop(gettextf(\"arguments imply differing number of rows: %s\", . paste(unique(nrows), collapse = \", \")), domain = NA) # since those vectors were of different lengths, R couldn't create a data frame. # below, i use length() and cat() functions to return the lengths of the vectors we tried to combine to a data frame above. cat(length(vec1),length(vec2),length(vec3)) 5 6 4 vec15 <- c(vec1,-1) vec16 <- c('one', \"two\", vec3) # note that vec15, vec2 and vec16 have the same length after modifying them for the sake of this example. cat(length(vec15),length(vec2),length(vec16)) 6 6 6 # we can create the data frame. data.frame(vec15,vec2,vec16) A data.frame: 6 \u00d7 3 vec15 vec2 vec16 1 TRUE one 2 TRUE two 3 FALSE a 20 FALSE stats 3 FALSE 614 -1 TRUE ' # it's customary to denote the variable that represents a data frame # by the variable name df df <- data.frame(a = vec15,b = vec2,c = vec16, d = vec2 + vec15) df A data.frame: 6 \u00d7 4 a b c d 1 TRUE one 2 2 TRUE two 3 3 FALSE a 3 20 FALSE stats 20 3 FALSE 614 3 -1 TRUE ' 0 Matrices # the matrix function creates a matrix below that contains 3 rows and 2 columns # the difference of a matrix is that the data types of the items in a matrix need to be equal # you can think of matrices as a 2D generalization of vectors. mymatrix = matrix(vec16, 3, 2) mymatrix A matrix: 3 \u00d7 2 of type chr one stats two 614 a ' # finding the transpose matrix: columns are converted to rows and rows to columns. # for example, the first column of the matrix above is the first row of the transpose below. t(mymatrix) A matrix: 2 \u00d7 3 of type chr one two a stats 614 ' Indexing # how to grab the second value of a vector vec3[2] 'stats' vec3 'a' 'stats' '614' '\\'' 1:3 # means all the numbers between 1 and 3 (1 and 3 included) 1 2 3 # what if we want more values vec3[1:3] 'a' 'stats' '614' vec3[-1] 'stats' '614' '\\'' Filtering using Boolean values length(vec3) 4 vec3[c(T,T,F,T)] 'a' 'stats' '\\'' vec3[c(1,2,4)] 'a' 'stats' '\\'' vec3[5] NA # similar with lists, but remember: you get sublists mylist 1 TRUE 'A' mylist[1:2] 1 TRUE mylist[1] 1 typeof(mylist[1]) 'list' # to get the actual items mylist[[1]] 1 # giving names to items mylist4 <- list(\"a\" = vec1, \"vec2\" = vec2, namewithouthquotes = vec3, mynumber = 20, list(vec1, vec2, vec3), mean) mylist4 $a 1 2 3 20 3 $vec2 TRUE TRUE FALSE FALSE FALSE TRUE $namewithouthquotes 'a' 'stats' '614' '\\'' $mynumber 20 [[5]] 1 2 3 20 3 TRUE TRUE FALSE FALSE FALSE TRUE 'a' 'stats' '614' '\\'' [[6]] function (x, ...) UseMethod(\"mean\") # we gave names to items in the list names(mylist4) 'a' 'vec2' 'namewithouthquotes' 'mynumber' '' '' mylist4[1] 1 2 3 20 3 mylist4[\"a\"] 1 2 3 20 3 Slicing/indexing data frames df A data.frame: 6 \u00d7 4 a b c d 1 TRUE one 2 2 TRUE two 3 3 FALSE a 3 20 FALSE stats 20 3 FALSE 614 3 -1 TRUE ' 0 df$a 1 2 3 20 3 -1 df[\"a\"] A data.frame: 6 \u00d7 1 a 1 2 3 20 3 -1 df[[\"a\"]] 1 2 3 20 3 -1 df[[1]] 1 2 3 20 3 -1 df[1][4] Error in `[.data.frame`(df[1], 4): undefined columns selected Traceback: 1. df[1][4] 2. `[.data.frame`(df[1], 4) 3. stop(\"undefined columns selected\") # 1st column 4th row df[[1]][4] 20 df[[1]][4:6] 20 3 -1 # first row 4th column df[1,4] 2 df[4,1] 20 df[1,] A data.frame: 1 \u00d7 4 a b c d 1 1 TRUE one 2 df[c(1,2,4),] A data.frame: 3 \u00d7 4 a b c d 1 1 TRUE one 2 2 2 TRUE two 3 4 20 FALSE stats 20 mymatrix A matrix: 3 \u00d7 2 of type chr one stats two 614 a ' mymatrix[1,2] 'stats' Functions new_sum <- function(value1, value2){ results <- value1 + value2 return(results) } new_sum(2,4) 6 new_division <- function(x,y){ return(y/x) } new_division(5,4) 0.8 new_division(y=4,x=5) 0.8 new_division function (x, y) { return(y/x) } ?mean Packages # installing a library install.packages(\"ggplot2\") Updating HTML index of packages in '.Library' Making 'packages.html' ... done # importing a library library(ggplot2) # once you import a library, you can call any function from that library ggplot(df, aes(a,b)) + geom_point()","title":"00 - Intro to R"},{"location":"intro_to_r/#lecture-1-preliminaries","text":"","title":"Lecture 1: Preliminaries"},{"location":"intro_to_r/#r-and-rstudio","text":"R is a statistical computing environment: open source and free software for statistical computation and graphics and a computer language designed for typical statistical and graphical applications R is an interpreted language: You type some commands (via at terminal/command prompt or from a file called a script), and R processes those commands. In this course, we will use RStudio to interact with R . RStudio is an integrated development environment, in other words user friendly software to interact with a language.","title":"R and RStudio"},{"location":"intro_to_r/#how-to-install-r-and-rstudio","text":"You can install R from: The Comprehensive R Archive Network You can install RStudio from: Download the RStudio IDE - RStudio Here's a webpage that explains the installation process in steps for different operating systems: Install R and RStudio - A Step-by-Step Guide for Beginners - TechVidvan Here's a Youtube tutorial for MacOS: How to install R and RStudio on Mac - YouTube Here's a Youtube tutorial for Windows: How to download and install R and RStudio - YouTube","title":"How to install R and RStudio"},{"location":"intro_to_r/#basic-calculations-in-r","text":"You can use R as a calculator and let it process a one line operation: 1+2 3 Here's a tidy website that contains a list of useful operators: R Operators - Learn By Example In this course, we'll be doing more complex computations and we'll need to save the result of a computation to be used later in some other computation. For that reason, we have variables . You can think of a variable as a keyword you chose to store a particular piece of information (numerical, or text or even logical). In R , there are two ways to assign a value to a variable: using = and using <- First you type the name of the variable you chose, then you type = or <- and then you put what value you want to assign to that variable. That value can be the result of some calculation, can be the output of some function, it can be a number or text or logical value you want to store. # note that, when you make an assignment, you don't get an output. # if you're using RStudio, the variable and its value can be seen in the Environment pane a = 3 ^ 2 #(example: exponentiation) # if you want R to return the value of a variable to the console, you'll need to type the name a 9 b <- 8 %/% 3 #(example: integer division) b 2 # you can see the variables in RStudio in a nice, organized way in the Environment pane # but if you want to see a list of variables in the Console: ls() 'a' 'b' Note that R is case sensitive, for example a and A are treated as different variable names. A = 7 a 9 A 7 If you want to update the value of a variable, you can do that of course. A = 10 # now the value of A is not 7 anymore, but 10. A 10","title":"Basic calculations in R"},{"location":"intro_to_r/#basic-data-types-in-r","text":"Here's a nice reference for more on basic data types and data structures in R : https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/ There are 6 data types in R : character numeric (real or decimal) integer logical complex You can find out the type of an object using the typeof() function. We'll discuss functions below, but basically they are self-contained algorithms built to perform a specific task. A function expects a user to give arguments as input and based on the values of the arguments, a function produces an output. # character values are anything that is to be treated as text typeof(\"ab\") 'character' In the example above, we gave \"ab\" as the input to the function typeof() by typing \"ab\" between the parentheses, and the typeof() function returned us the type of \"ab\" as the output. # R will decide how to store the value unless you specify the data type manually typeof(2) 'double' (If you wonder why the word 'double', double just means a decimal number in double precision, i.e. two decimals after the decimal point.) # by using '' or \"\", we can tell R that we're using a characters typeof('2') 'character' You can store text in a variable as well. To store a text value, you'll need to use \" or ' . Otherwise, R thinks you're typing the name of a variable. # note the the ' signs between the \" signs are treated as apostrophes: mytext <- \"I'm having a great 'day' today.\" mytext 'I\\'m having a great \\'day\\' today.' The backslash before the apostrophe \\' is R 's way of remembering that ' sign is to be treated as an apostrophe, but not as a delimiter of some text data. # the backslashes above are to denote escape sequences # \\' tells R to treat the apostrophe as a character # to print nicely, you can use the cat() function cat(mytext) I'm having a great 'day' today. typeof(2L) # the L on the right tells R to store 2 as an integer 'integer' typeof(-12.4) 'double' typeof(T) 'logical' typeof(FALSE) 'logical' typeof(1+4i) 'complex'","title":"Basic Data Types in R"},{"location":"intro_to_r/#basic-data-structures-in-r","text":"Data structures are ways to store (usually multiple) values together in a specific way. R has multiple data structures. The most important ones for us include: atomic vector list matrix data frame factors # you can think of vectors as lists/arrays # that contain items of the same type # the function c() below combines items to create vectors vec1 <- c(1,2,3,20,3) vec2 <- c(T,T,F,F,FALSE, TRUE) vec3 <- c('a','stats', '614', \"\\'\") vec4 <- c(2L, -5L) vec5 <- 1:10 length(vec1) 5 typeof(vec2) 'logical' typeof(vec3) 'character' cat(vec4) 2 -5 2*vec4 4 -10 vec5 1 2 3 4 5 6 7 8 9 10 vec6 <- vec5 - vec5 vec6 0 0 0 0 0 0 0 0 0 0 vec4 + vec6 2 -5 2 -5 2 -5 2 -5 2 -5 vec7 <- c(1,2,3) typeof(vec7) 'double' vec8 <- c(1L,2L,3L) typeof(vec8) 'integer' # in R, == means comparing and asking if the items are equal vec7 == vec8 TRUE TRUE TRUE # the str() function compactly displayes the internal STRucture of an R object # rdocumentation.org/packages/utils/versions/3.6.2/topics/str str(vec8) int [1:3] 1 2 3","title":"Basic Data Structures in R"},{"location":"intro_to_r/#how-to-add-a-new-element","text":"# below, i'm combining vec8 and the number 4 as an integer, # the number 4 is appended on the right, # hence the last item of vec9 is 4 vec9 <- c(vec8,4L) vec9 1 2 3 4 # below, the number zero is appended to vec9 on the left, # i.e. the first item in vec10 is 0 vec10 <- c(0L,vec9) vec10 0 1 2 3 4","title":"How to add a new element"},{"location":"intro_to_r/#how-to-create-vectors-from-a-sequence-of-numbers","text":"# the 1:10 command creates a sequence of integers that start at 1 and end at 10 vec11 <- 1:10 vec11 1 2 3 4 5 6 7 8 9 10 # you can create sequences more directly using the seq() function # you specify where the sequence of numbers start, end and the stepsize. vec12 <- seq(from = 1, to = 2, by = 0.1) vec12 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 # if the stepsize is not given, the default stepsize is used, which is 1. vec12 <- seq(from = 1, to = 20) vec12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20","title":"How to create vectors from a sequence of numbers"},{"location":"intro_to_r/#factors","text":"Factors are categorical variables in R . We'll talk about categorical variables and factors later, but as foreshadowing, we can use categorical variables to create hierarchies in the sense that we can compute the mean age of everyone, and at a detailed level, we can compute the mean age of female and male people using \"Female\" and \"Male\" categories. vec13 = as.factor(c(\"Male\", \"Female\", \"Male\", \"Female\")) vec13 Male Female Male Female Levels : 'Female' 'Male' # note that R automatically decides what the underlying data type is when creating a vector # the items in a vector need to be of the same data type. vec14 = c(1,TRUE,'A') class(vec14) 'character'","title":"Factors"},{"location":"intro_to_r/#lists","text":"# what if we want to store items of different data types and keep the data types as they are? # we use lists mylist <- list(1,TRUE,'A') mylist 1 TRUE 'A' typeof(mylist) 'list' mylist2 <- list(mylist, c(1,2,3)) mylist2 1 TRUE 'A' 1 2 3 mylist3 <- c(mylist, c(1,2,3)) mylist3 1 TRUE 'A' 1 2 3","title":"Lists"},{"location":"intro_to_r/#data-frames","text":"You can think of data frames as lists of vectors of equal length forming columns. Or even better, like a spreadsheet. # to create a data frame from vectors, you can use the data.frame() function data.frame(vec1,vec2,vec3) Error in data.frame(vec1, vec2, vec3): arguments imply differing number of rows: 5, 6, 4 Traceback: 1. data.frame(vec1, vec2, vec3) 2. stop(gettextf(\"arguments imply differing number of rows: %s\", . paste(unique(nrows), collapse = \", \")), domain = NA) # since those vectors were of different lengths, R couldn't create a data frame. # below, i use length() and cat() functions to return the lengths of the vectors we tried to combine to a data frame above. cat(length(vec1),length(vec2),length(vec3)) 5 6 4 vec15 <- c(vec1,-1) vec16 <- c('one', \"two\", vec3) # note that vec15, vec2 and vec16 have the same length after modifying them for the sake of this example. cat(length(vec15),length(vec2),length(vec16)) 6 6 6 # we can create the data frame. data.frame(vec15,vec2,vec16) A data.frame: 6 \u00d7 3 vec15 vec2 vec16 1 TRUE one 2 TRUE two 3 FALSE a 20 FALSE stats 3 FALSE 614 -1 TRUE ' # it's customary to denote the variable that represents a data frame # by the variable name df df <- data.frame(a = vec15,b = vec2,c = vec16, d = vec2 + vec15) df A data.frame: 6 \u00d7 4 a b c d 1 TRUE one 2 2 TRUE two 3 3 FALSE a 3 20 FALSE stats 20 3 FALSE 614 3 -1 TRUE ' 0","title":"Data Frames"},{"location":"intro_to_r/#matrices","text":"# the matrix function creates a matrix below that contains 3 rows and 2 columns # the difference of a matrix is that the data types of the items in a matrix need to be equal # you can think of matrices as a 2D generalization of vectors. mymatrix = matrix(vec16, 3, 2) mymatrix A matrix: 3 \u00d7 2 of type chr one stats two 614 a ' # finding the transpose matrix: columns are converted to rows and rows to columns. # for example, the first column of the matrix above is the first row of the transpose below. t(mymatrix) A matrix: 2 \u00d7 3 of type chr one two a stats 614 '","title":"Matrices"},{"location":"intro_to_r/#indexing","text":"# how to grab the second value of a vector vec3[2] 'stats' vec3 'a' 'stats' '614' '\\'' 1:3 # means all the numbers between 1 and 3 (1 and 3 included) 1 2 3 # what if we want more values vec3[1:3] 'a' 'stats' '614' vec3[-1] 'stats' '614' '\\''","title":"Indexing"},{"location":"intro_to_r/#filtering-using-boolean-values","text":"length(vec3) 4 vec3[c(T,T,F,T)] 'a' 'stats' '\\'' vec3[c(1,2,4)] 'a' 'stats' '\\'' vec3[5] NA # similar with lists, but remember: you get sublists mylist 1 TRUE 'A' mylist[1:2] 1 TRUE mylist[1] 1 typeof(mylist[1]) 'list' # to get the actual items mylist[[1]] 1 # giving names to items mylist4 <- list(\"a\" = vec1, \"vec2\" = vec2, namewithouthquotes = vec3, mynumber = 20, list(vec1, vec2, vec3), mean) mylist4 $a 1 2 3 20 3 $vec2 TRUE TRUE FALSE FALSE FALSE TRUE $namewithouthquotes 'a' 'stats' '614' '\\'' $mynumber 20 [[5]] 1 2 3 20 3 TRUE TRUE FALSE FALSE FALSE TRUE 'a' 'stats' '614' '\\'' [[6]] function (x, ...) UseMethod(\"mean\") # we gave names to items in the list names(mylist4) 'a' 'vec2' 'namewithouthquotes' 'mynumber' '' '' mylist4[1] 1 2 3 20 3 mylist4[\"a\"] 1 2 3 20 3","title":"Filtering using Boolean values"},{"location":"intro_to_r/#slicingindexing-data-frames","text":"df A data.frame: 6 \u00d7 4 a b c d 1 TRUE one 2 2 TRUE two 3 3 FALSE a 3 20 FALSE stats 20 3 FALSE 614 3 -1 TRUE ' 0 df$a 1 2 3 20 3 -1 df[\"a\"] A data.frame: 6 \u00d7 1 a 1 2 3 20 3 -1 df[[\"a\"]] 1 2 3 20 3 -1 df[[1]] 1 2 3 20 3 -1 df[1][4] Error in `[.data.frame`(df[1], 4): undefined columns selected Traceback: 1. df[1][4] 2. `[.data.frame`(df[1], 4) 3. stop(\"undefined columns selected\") # 1st column 4th row df[[1]][4] 20 df[[1]][4:6] 20 3 -1 # first row 4th column df[1,4] 2 df[4,1] 20 df[1,] A data.frame: 1 \u00d7 4 a b c d 1 1 TRUE one 2 df[c(1,2,4),] A data.frame: 3 \u00d7 4 a b c d 1 1 TRUE one 2 2 2 TRUE two 3 4 20 FALSE stats 20 mymatrix A matrix: 3 \u00d7 2 of type chr one stats two 614 a ' mymatrix[1,2] 'stats'","title":"Slicing/indexing data frames"},{"location":"intro_to_r/#functions","text":"new_sum <- function(value1, value2){ results <- value1 + value2 return(results) } new_sum(2,4) 6 new_division <- function(x,y){ return(y/x) } new_division(5,4) 0.8 new_division(y=4,x=5) 0.8 new_division function (x, y) { return(y/x) } ?mean","title":"Functions"},{"location":"intro_to_r/#packages","text":"# installing a library install.packages(\"ggplot2\") Updating HTML index of packages in '.Library' Making 'packages.html' ... done # importing a library library(ggplot2) # once you import a library, you can call any function from that library ggplot(df, aes(a,b)) + geom_point()","title":"Packages"}]}